package coyote.commons.jdbc.datasource;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;


/**
 * Used by {@code CloseOnCompletionDataSource} to return connections which will
 * be closed then the connection is closed. It wraps {@code Connection} objects
 * which are tracked by the aforementioned datasource and closed when the 
 * datasource is closed.
 */
public class CloseOnCompletionConnection extends ConnectionProxy {

  private final Connection _originalConnection;
  private final Queue<Statement> _statementsToBeClosed;




  public CloseOnCompletionConnection( final Connection originalConnection ) {
    super( originalConnection );
    _originalConnection = originalConnection;
    _statementsToBeClosed = new ConcurrentLinkedQueue<Statement>();
  }




  @Override
  public void abort( final Executor executor ) throws SQLException {
    _originalConnection.abort( executor );
  }




  @Override
  public void close() throws SQLException {
    try {
      for ( final Statement statementToBeClosed : _statementsToBeClosed ) {
        if ( !statementToBeClosed.isClosed() ) {
          statementToBeClosed.close();
        }
      }
    }
    finally {
      _originalConnection.close();
    }
  }




  @Override
  public Statement createStatement() throws SQLException {
    final Statement statement = _originalConnection.createStatement();
    _statementsToBeClosed.add( new CloseOnCompletionStatement( statement ) );
    return statement;
  }




  @Override
  public Statement createStatement( final int resultSetType, final int resultSetConcurrency ) throws SQLException {
    final Statement statement = _originalConnection.createStatement( resultSetType, resultSetConcurrency );
    _statementsToBeClosed.add( new CloseOnCompletionStatement( statement ) );
    return statement;
  }




  @Override
  public Statement createStatement( final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability ) throws SQLException {
    final Statement statement = _originalConnection.createStatement( resultSetType, resultSetConcurrency, resultSetHoldability );
    _statementsToBeClosed.add( new CloseOnCompletionStatement( statement ) );
    return statement;
  }




  @Override
  protected void finalize() throws Throwable {
    try {
      if ( !isClosed() ) {
        close();
      }
    }
    finally {
      super.finalize();
    }
  }




  @Override
  public int getNetworkTimeout() throws SQLException {
    return _originalConnection.getNetworkTimeout();
  }




  @Override
  public String getSchema() throws SQLException {
    return _originalConnection.getSchema();
  }




  @Override
  public CallableStatement prepareCall( final String sql ) throws SQLException {
    final CallableStatement callableStatement = _originalConnection.prepareCall( sql );
    _statementsToBeClosed.add( new CloseOnCompletionCallableStatement( callableStatement ) );
    return callableStatement;
  }




  @Override
  public CallableStatement prepareCall( final String sql, final int resultSetType, final int resultSetConcurrency ) throws SQLException {
    final CallableStatement callableStatement = _originalConnection.prepareCall( sql, resultSetType, resultSetConcurrency );
    _statementsToBeClosed.add( new CloseOnCompletionCallableStatement( callableStatement ) );
    return callableStatement;
  }




  @Override
  public CallableStatement prepareCall( final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability ) throws SQLException {
    final CallableStatement callableStatement = _originalConnection.prepareCall( sql, resultSetType, resultSetConcurrency, resultSetHoldability );
    _statementsToBeClosed.add( new CloseOnCompletionCallableStatement( callableStatement ) );
    return callableStatement;
  }




  @Override
  public PreparedStatement prepareStatement( final String sql ) throws SQLException {
    final PreparedStatement preparedStatement = _originalConnection.prepareStatement( sql );
    _statementsToBeClosed.add( new CloseOnCompletionPreparedStatement( preparedStatement ) );
    return preparedStatement;
  }




  @Override
  public PreparedStatement prepareStatement( final String sql, final int autoGeneratedKeys ) throws SQLException {
    final PreparedStatement preparedStatement = _originalConnection.prepareStatement( sql, autoGeneratedKeys );
    _statementsToBeClosed.add( new CloseOnCompletionPreparedStatement( preparedStatement ) );
    return preparedStatement;
  }




  @Override
  public PreparedStatement prepareStatement( final String sql, final int resultSetType, final int resultSetConcurrency ) throws SQLException {
    final PreparedStatement preparedStatement = _originalConnection.prepareStatement( sql, resultSetType, resultSetConcurrency );
    _statementsToBeClosed.add( new CloseOnCompletionPreparedStatement( preparedStatement ) );
    return preparedStatement;
  }




  @Override
  public PreparedStatement prepareStatement( final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability ) throws SQLException {
    final PreparedStatement preparedStatement = _originalConnection.prepareStatement( sql, resultSetType, resultSetConcurrency, resultSetHoldability );
    _statementsToBeClosed.add( new CloseOnCompletionPreparedStatement( preparedStatement ) );
    return preparedStatement;
  }




  @Override
  public PreparedStatement prepareStatement( final String sql, final int[] columnIndexes ) throws SQLException {
    final PreparedStatement preparedStatement = _originalConnection.prepareStatement( sql, columnIndexes );
    _statementsToBeClosed.add( new CloseOnCompletionPreparedStatement( preparedStatement ) );
    return preparedStatement;
  }




  @Override
  public PreparedStatement prepareStatement( final String sql, final String[] columnNames ) throws SQLException {
    final PreparedStatement preparedStatement = _originalConnection.prepareStatement( sql, columnNames );
    _statementsToBeClosed.add( new CloseOnCompletionPreparedStatement( preparedStatement ) );
    return preparedStatement;
  }




  @Override
  public void setNetworkTimeout( final Executor executor, final int milliseconds ) throws SQLException {
    _originalConnection.setNetworkTimeout( executor, milliseconds );
  }




  @Override
  public void setSchema( final String schema ) throws SQLException {
    _originalConnection.setSchema( schema );
  }
}
